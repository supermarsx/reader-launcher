name: Auto-release

on:
  workflow_run:
    workflows: ["Build"]
    types:
      - completed

jobs:
  publish-release:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Compute next release tag (0.YY.N)
        id: compute_tag
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner
            const repo = context.repo.repo
            const fullYear = new Date().getFullYear()
            const yy = String(fullYear).slice(-2)

            // look at existing releases and tags; accept both formats (YY.N and 0.YY.N)
            const releases = await github.rest.repos.listReleases({ owner, repo })
            let max = 0
            for (const r of releases.data) {
              // accept 23.4 or 0.23.4
              const m = r.tag_name.match(new RegExp('^(?:0\.)?' + yy + '\.(\\d+)$'))
              if (m) {
                const v = parseInt(m[1], 10)
                if (v > max) max = v
              }
            }
            const next = max + 1
            const tag = `0.${yy}.${next}`
            core.info(`Next release tag will be ${tag}`)
            return tag

      - name: Prepare release commit & tag (bump VERSION, update sources)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Git for version bump commit
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Bump VERSION and sync source
        env:
          TAG_NAME: ${{ steps.compute_tag.outputs.result }}
        run: |
          # Avoid passing surrounding quotes into the script accidentally; print and pass the raw value
          echo "Setting version to ${TAG_NAME//\"/}"
          pwsh -NoProfile -ExecutionPolicy Bypass -File scripts/bump-version.ps1 -Version "${TAG_NAME//\"/}"
          git add version src/reader_launcher.au3 || true
          if ! git diff --cached --quiet; then
            git commit -m "chore(release): bump version to $TAG_NAME [skip ci]" || true
          fi

      - name: Tag & push release commit
        env:
          TAG_NAME: ${{ steps.compute_tag.outputs.result }}
        run: |
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin HEAD --follow-tags

      - name: Create GitHub release from tag
        id: create_release
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner
            const repo = context.repo.repo
            const tag = process.env.TAG_NAME || '${{ steps.compute_tag.outputs.result }}'
            core.info(`Creating release ${tag}`)
            const rel = await github.rest.repos.createRelease({ owner, repo, tag_name: tag, name: tag, body: `Automated release ${tag}`, draft: false, prerelease: false })
            return rel.data.id

      - name: Download artifacts from successful Build run
        env:
          RUN_ID: ${{ github.event.workflow_run.id }}
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching artifacts for run $RUN_ID"
          API="https://api.github.com/repos/${{ github.repository }}/actions/runs/$RUN_ID/artifacts"
          curl -s -H "Authorization: Bearer $TOKEN" -H "Accept: application/vnd.github+json" "$API" > artifacts.json
          cat artifacts.json
          # find the artifact named reader-launcher-dist
          ART_URL=$(jq -r '.artifacts[] | select(.name=="reader-launcher-dist") | .archive_download_url' artifacts.json)
          if [ "$ART_URL" = "" ] || [ "$ART_URL" = "null" ]; then
            echo "No reader-launcher-dist artifact found for build run: $RUN_ID"
            exit 1
          fi
          echo "Found artifact: $ART_URL"
          curl -L -H "Authorization: Bearer $TOKEN" -o artifact.zip "$ART_URL"
          unzip -o artifact.zip -d artifact
          # determine whether the artifact contains a dist/ subfolder or files in the root
          if [ -d artifact/dist ]; then
            echo "Detected artifact/dist — using artifact/dist as the artifact base"
            echo "ARTIFACT_DIR=artifact/dist" >> $GITHUB_ENV
          else
            echo "artifact/dist not found — using artifact as the artifact base"
            echo "ARTIFACT_DIR=artifact" >> $GITHUB_ENV
          fi

      - name: Attach build artifacts to release
        env:
          RELEASE_ID: ${{ steps.create_release.outputs.result }}
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Attaching artifacts to release id $RELEASE_ID"
          REPO="${{ github.repository }}"
          # upload any files found under artifact/dist
          ls artifact
          if [ -d "$ARTIFACT_DIR" ]; then
            for f in "$ARTIFACT_DIR"/*; do
              fname=$(basename "$f")
              echo "Uploading $fname to release $RELEASE_ID"
              curl -s -X POST -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/octet-stream" --data-binary @"$f" "https://uploads.github.com/repos/$REPO/releases/$RELEASE_ID/assets?name=$fname"
            done
            # also attach the original artifact.zip (downloaded archive) for debugging
            if [ -f artifact.zip ]; then
              echo "Uploading artifact.zip to release $RELEASE_ID"
              curl -s -X POST -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/octet-stream" --data-binary @artifact.zip "https://uploads.github.com/repos/$REPO/releases/$RELEASE_ID/assets?name=artifact.zip"
            fi
          else
            echo "No artifact/dist found to upload"
            exit 1
          fi

      - name: Generate artifact verification summary
        env:
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p verify_results
          if [ -d "$ARTIFACT_DIR" ]; then
            for f in "$ARTIFACT_DIR"/*; do
              fname=$(basename "$f")
              echo "--- Verifying $fname ---" >> verify_results/verify_summary.txt
              sha256=$(sha256sum "$f" | awk '{print $1}')
              echo "File: $fname SHA256: $sha256" >> verify_results/verify_summary.txt
              echo "Checking checksums..." >> verify_results/verify_summary.txt
            done
            # attach a lightweight verify_summary (checksums only) to the release
            RELEASE_ID=${{ steps.create_release.outputs.result }}
            if [ -f verify_results/verify_summary.txt ]; then
              echo "Attaching verify_results/verify_summary.txt to release $RELEASE_ID"
              curl -s -X POST -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/octet-stream" --data-binary @verify_results/verify_summary.txt "https://uploads.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID/assets?name=verify_summary.txt"
            fi
          else
            echo "No artifacts found to summarize"
          fi

      - name: Verify artifacts against checksums
        env:
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          mkdir -p verify_results
          if [ -d "$ARTIFACT_DIR" ]; then
            FAIL=0
            for f in "$ARTIFACT_DIR"/*; do
              fname=$(basename "$f")
              echo "--- Verifying $fname ---" >> verify_results/verify_summary.txt
              if [ -f "$ARTIFACT_DIR/checksums.txt" ]; then
                checksPath="$ARTIFACT_DIR/checksums.txt"
              else
                checksPath=artifact/dist/checksums.txt
              fi
              pwsh -NoProfile -ExecutionPolicy Bypass -File scripts/verify-release.ps1 -ArtifactPath "$f" -Checksums "$checksPath" > verify_results/verify_$fname.txt 2>&1
              rc=$?
              cat verify_results/verify_$fname.txt >> verify_results/verify_summary.txt
              if [ $rc -ne 0 ]; then
                echo "Checksum verification failed for $fname (rc=$rc)" >> verify_results/verify_summary.txt
                FAIL=1
              fi
            done
            # attach verify_summary to release for convenience
            RELEASE_ID=${{ steps.create_release.outputs.result }}
            if [ -f verify_results/verify_summary.txt ]; then
              echo "Attaching verify_results/verify_summary.txt to release $RELEASE_ID"
              curl -s -X POST -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/octet-stream" --data-binary @verify_results/verify_summary.txt "https://uploads.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID/assets?name=verify_summary.txt"
            fi
            if [ "$FAIL" = "1" ]; then
              echo "Verification failed — aborting release"
              exit 1
            fi
          else
            echo "No artifacts found to verify"
          fi
      - name: Add checksums and verification summary to release body
        env:
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_ID: ${{ steps.create_release.outputs.result }}
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs')
            // prefer environment-specified ARTIFACT_DIR if present
            const artifactDir = process.env.ARTIFACT_DIR && process.env.ARTIFACT_DIR.length ? process.env.ARTIFACT_DIR : 'artifact/dist'
            let bodySections = []
            // append checksums if present
            const checksPath = `${artifactDir}/checksums.txt`
            if (fs.existsSync(checksPath)) {
              const checks = fs.readFileSync(checksPath, 'utf8')
              bodySections.push('### Checksums\n```\n' + checks + '\n```')
            }
            // append verify summary if present
            const verifyPath = 'verify_results/verify_summary.txt'
            if (fs.existsSync(verifyPath)) {
              const v = fs.readFileSync(verifyPath, 'utf8')
              bodySections.push('### Verification summary\n```\n' + v + '\n```')
            }
            const releaseId = parseInt(process.env.RELEASE_ID, 10)
            // Read existing release body
            const owner = context.repo.owner
            const repo = context.repo.repo
            const rel = await github.rest.repos.getRelease({ owner, repo, release_id: releaseId })
            let body = rel.data.body || ''
            if (bodySections.length > 0) {
              body += '\n\n' + bodySections.join('\n\n')
              await github.rest.repos.updateRelease({ owner, repo, release_id: releaseId, body })
            }
